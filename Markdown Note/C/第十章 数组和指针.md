## 10.1数组

**数组由数据类型相同的一系列元素组成** 通过声明数组告诉编译器数组中内含多少元素和这些元素的类型

**声明数组的通用形式**：

```c
type name[容量];
```

如:

```c
float candy[365];  //	内含365个float类型元素的数组
char code[12];   //内含12个char类型元素的数组
int states[50];  //内含50个int类型元素的数组
```

方括号[]表示了变量都是数组，方括号中的数字表明数组中的元素个数。

**要访问数组中的元素，通过使用数组下标数（索引）表示数组中的各元素。数组元素的编号从0开始**，所以candy[0]表示candy数组的第一个元素。candy[364]表示第365个元素，也就是最后一个元素。

#### 10.1.1 初始化数组

数组通常被用来储存程序需要的数据。例如，使用数组储存12个月的天数，这种情况下，可以在声明数组时进行初始化比较好。

```c
int month[12]={31,28,31,30,31,30,31,31,30,31,30,31};
```

如上所示，以逗号分割的值列表（用花括号扩起来）来初始化数组。上面把31赋给数组的首元素（month[0])，依次类推（不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前面加上关键字static可解决此问题）

我们编写一个程序，打印每个月的天数：

```c
#include<stdio.h>
#define MONTH 12
int main() {
	int month[MONTH] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
	for (int i = 0;i < MONTH;i++) {
		printf("%d月有：%d天\n", i + 1, month[i]);
	}
}
```

输出：

```c
1月有：31天
2月有：28天
3月有：31天
4月有：30天
5月有：31天
6月有：30天
7月有：31天
8月有：31天
9月有：30天
10月有：31天
11月有：30天
12月有：31天
```

该例使用了符号常量MONTH表示数组大小，这是我们推荐且常用的做法。这样我们要修改数组大小时，只需要修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方。



**使用const声明数组**

*有时需要把数组设置为只读，这样程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组。如：*

```c
const  int month[MONTH] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
```

这样修改后，程序在运行过程中就不能修改该数组中的内容。



**如果初始化数组失败后怎么办**?下面的程序演示了这种情况

```c
#include<stdio.h>
#define SIZE 4
int main() {
	int no_data[SIZE]; //未初始化值
	int i;
	printf("%2s%14s\n", "i", "no_data[i]");
	for (i = 0;i < SIZE;i++) {
		printf("%2d%14d\n", i, no_data[i]);
	}
}
```

输出：

```c
 i    no_data[i]
 0    -858993460
 1    -858993460
 2    -858993460
 3    -858993460
```

 使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，在每台设备上运行该程序输出会与示例不同。



初始化列表中的项数应与数组的大小一致。如果不一致会怎么样？还是以上一个程序为例，但初始化列表中缺少两个元素

```c
#include<stdio.h>
#define SIZE 4
int main() {
	int no_data[SIZE]={123,321};
	int i;
	printf("%2s%14s", "i", "no_data[i]");
	for (i = 0;i < SIZE;i++) {
		printf("%2d%14d\n", i, no_data[i]);
	}
}
```

输出：

```c
 i    no_data[i]
 0           123
 1           321
 2             0
 3             0
```

如上所示，**当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素初始化为0**

也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其存储的都是“垃圾值”;但是如果部分初始化数组，剩余的元素就被初始化为0。



如果初始化列表的项数多于数组元素格式，编译器会将其视为错误。其实，**可以省略方括号中的数字，让编译器自动匹配数字大小和初始化列表中的项数**

```c
#include<stdio.h>
int main() {
	int month[] = { 31,28,31,30,31,30,31,31,30,31,30,31 };
	for (int index = 0;index<sizeof month / sizeof month[0];index++) {
		printf("%d月有：%d天\n", index + 1, month[index]);
	}
}
```

对于上面的程序，要注意以下两点:

- 如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小
- 注意for循环中的测试条件。 sizeof运算符给出它的运算对象的大小（以字节为单位）。所以 sizeof month是整个数组的大小，sizeof month[0]是数组中一个元素的大小。**整个数组的大小除以单个元素的大小就是数组元素的个数**。

下面是该程序的输出：

```c
1月有：31天
2月有：28天
3月有：31天
4月有：30天
5月有：31天
6月有：30天
7月有：31天
8月有：31天
9月有：30天
10月有：31天
11月有：30天
12月有：31天
```



#### 10.1.2 指定初始化器（C99）

**指定初始化器可以初始化指定的数组元素。如只初始化数组中的最后一个元素**。对于传统的C初始化语法，必须初始化最后一个元素之前所有的元素才能初始化它：

```c
int arr[6]={0,0,0,0,0,121}; //传统的语法
```

C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：

```c
int arr[6]={[5]=212};  //把arr[5]初始化为212
```

对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。但对于指定初始化器情况不一样



```c
#include<stdio.h>
#define MONTHS 12
int main() {
	int month[MONTHS] = { 31,28,[4] = 31,30,31,[1] = 29 };

	for (int i = 0;i < MONTHS;i++) {
		printf("%2d  %d\n", i + 1, month[i]);
	}
}
```

对于这个指定初始化器，如果你的编译器报错，请检查源文件是否为.c而并非是.cpp。或者检查编译器是否支持c99

输出：

```c
 1  31
 2  29
 3  0
 4  0
 5  31
 6  30
 7  31
 8  0
 9  0
10  0
11  0
12  0
```

指定初始化器的两个重要特性。**第一，如果指定初始化器后面有更多的值，那么后面的值将被用于初始化指定元素后面的元素**。如这个示例中：[4]=31,30,31。就是说，month[4]被初始化为31后，month[5]和month[6]分别被初始化为30和31。

**第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化**。例如，初始化列表开始吧month[1]初始化为28，但是month[1]又被后面的指定初始化[1]=29初始化为29。



如果未指定元素大小会怎样？

int stuff[]={1,[6]=23};

int staff[]={1,[6]=4,9,10};

**编译器会把数组的大小设置为足够装得下初始化的值**。所以，stuff数组有7个元素，而staff数组的元素比stuff数组多两个，即9个。



#### 10.1.3 给数组元素赋值

声明数组后，可以借助数组下标给数组元素赋值

```c
/*给数组的元素赋值*/
#include<stdio.h>
#define SIZE 50
int main()
{
    int counter,evens[SIZE];
    
    for(counter=0;counter<SIZE;counter++)
        evens[counter]=2*counter;
   
    return 0;
}
```

这段代码中使用循环给数组中的元素依次赋值。

**C不允许把数组作为一个单元赋给另一个数组。除了初始化以外也不允许使用花括号列表的形式赋值**。

下面的代码演示了一些**错误**的赋值形式；

```c
/* 一些无效的数组赋值 */
#define SIZE 5
int main(){
    int oxen[SIZE] = {5,3,2,8};  /*有效初始化*/
    int yaks[SIZE]; 
    
    yaks = oxen;  //不允许
    yaks[SIZE] = oxen[SIZE];  //数组下标越界
    yaks[SIZE]= {5,3,2,8};
}

```



#### 10.1.4 指定数组的大小

在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型常量，但const值不是。另外，表达式的值必须大于0：

```c
float al[5];
float a2[5*2+1];
float a3[sizeof(int)+1]
```

C99标准之后，运行创建一种新型数组：

```c
int a=5,b=6;
```



