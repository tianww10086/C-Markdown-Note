	本章将学习面向对象程序设计的另一个基本概念：继承。利用继承，人们可以给予已存在的类构造一个新类。继承已存在的类就是复用这些类的方法和域。在此基础上，还可以添加一些新的方法和域，以满足新的需求。这是Java程序设计中的一项核心技术。

​	另外。还将阐述反射的概念。反射是指在程序运行期间发现更多的类及其属性的能力。这是一个功能强大的特性，使用起来比较复杂，主要用于开发软件工具。





## 5.1 类、超类和子类

​	普通雇员在完成本职任务之后仅领取薪水。而经理在完成了预期的业绩之后还能得到讲解。这种关系就需要使用继承，将经理定义为一个新类Manager，以便增加一些新供能。可以重用Employee类中已经编写的部分代码，并将其中的所有与保留下来。



#### 5.1.1 定义子类

下面是由Employee类来定义Manager类的格式，关键字`extends`表示继承

```java
public class Manager extend Employee
{
 ...   
}
```

关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为`超类`、`基类`或`父类`；而新类称为`子类`、派生类。

在Manager类中，增加了一个用于存储奖金信息的域，以及一个用于设置这个域的新方法：

```java
public class Manager extend Employee
{
    private double bonus;
    
    public void setBonus(double bonus)
    {
        this.bonus=bonus;
    }
}
```

由于setBonus方法并不是在Employee类中定义的，所以属于Employee类的对象不能使用它。也就是父类无法使用子类方法。

​	然而，尽管Manager类中没有显式的定义getName等方法，但属于Manager类的对象却可以使用它们。Manager类自动地继承类父类Employee中的这些方法和属性。

​	**在通过扩展超类定义子类的时候，仅需指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中，而将具有特殊用途的方法放在子类中**。这种将通用的功能放到超类的做法，在面向对象程序设计中非常普遍。





#### 5.1.2 覆盖方法

父类中的有些方法对子类Manager不一定使用。此时，需要提供一个新的方法来覆盖（override）父类中的方法：

```java
public class Manager extend Employee
{
    private double bonus;
    
    public void setBonus(double bonus)
    {
        this.bonus=bonus;
    }
    public double getSalary()
    {
        ...
    }
}
```

​	Manager类中的getSalary（）方法应该返回薪水和奖金的总和。**但Manager类的getSalary方法不能直接地方法父类的私有成员。只有Employee类的方法才能够访问私有部分。如果Manager类的方法一定要访问私有域，那么就必须借用父类的公有接口,我们使用关键字super来调用属于父类的方法**：

```java
    public double getSalary()
    {
       double baseSalary=super.getSalary(); //调用父类方法访问Salary
       return baseSalar+bonus;
    }
```

也就是说，**子类无法直接访问父类的私有成员，但可以通过父类的方法来间接访问**。



#### 5.1.3 子类构造器

同样的，使用super关键字可以使用父类的构造器。

```java
public Manager(String name,double salar,int year,int month,int day)
{
    super(name,salar,year,month,day);
    bonus=0;
}
```

​	由于Manager类的构造器不能访问Employee类的私有成员。所以必须利用Employee的构造器进行初始化，**通过`super`实现对父类构造器的调用。使用super调用构造器的语句必须是子类构造器的第一条语句**。

​	

下面创建一个经理对象，并设置它的奖金：

```java
Manager Hr =new Manager("王五",15000,2009,12,06);
Hr.setBonus(5000);
```

定义一个包含3个雇员的数组：

```java
Employee[] arr =new Employee[3];
```

把经理和雇员都放到数组中：

```java
arr[0]=Hr;
arr[1]=new Employee("李四",12000,1989,10,1);
arr[2]=new Employee("张三",13000,1987,3,15);
```

输出每个人的薪水：

```java
 for(Employee e:employees)
       System.out.println("姓名："+e.getName()+" 工资："+e.getSalary());
```

输出结果：

```java
现在，每位员工的信息是
姓名：王五 工资：20000.0
姓名：李四 工资：4000.0
姓名：张三 工资：4500.0
```

​	尽管e声明为Employee类型，但e既可以引用Employee类型的对象，也可以引用子类Manager类型的对象。虚拟机知道e实际引用的对象类型，因此能够正确的调用相应的方法。也就是说，**父类对象可以引用子类对象**，是实现多态的关键。

当父类对象引用了子类对象时：

1. 若子类重写了父类的方法，通过父类引用调用该方法时，实际执行的是子类的方法。这是运行时多态的体现
2. 父类引用无法直接调用子类独有的方法，需通过向下转型，且转型前需确保对象确实是子类实例



**一个对象变量可以指示多种实际类型的现象被称为多态。在运行时能够自动地选择调用哪个方法的现象称为动态绑定**。

```java
package TWW;

import java.time.*;
public class EmployeeTest {
    public static void main(String[] args)
    {
        Manager Hr =new Manager("王五",15000,2009,12,06);
        Hr.setBonus(5000);
        //创建一个类数组，存储3位员工的信息
        Employee[] employees = new Employee[3];

        //使用构造方法
        employees[0]=Hr;
        employees[1]=new Employee("李四",4000,1991,8,16);
        employees[2]=new Employee("张三",4500,1998,1,21);
        
        System.out.println("现在，每位员工的信息是");
        for(Employee e:employees)
            System.out.println("姓名："+e.getName()+" 工资："+e.getSalary());

    }
}

/**
 * @author TIAN
 * @version 0.1
 * @since 0.1
 *
 * */
class Employee
{
    //私有成员
    private String name; //名字
    private double salary;//薪水
    private LocalDate hireDay; //雇佣日期

    //构造方法
    public Employee(String n,double s ,int year,int month,int Day)
    {
        name = n;
        salary = s;
        hireDay=LocalDate.of(year,month,Day);
    }

    //提供方法访问私有化成员
    public String getName()
    {
        return name;
    }

    public double getSalary()
    {
        return salary;
    }

    public LocalDate getHireDay()
    {
        return hireDay;
    }

    /**
     这个方法用于提高员工的工资
     @param byPercent 提高工资的百分比
     @return 返回加薪的金额
     */
    public void raiseSalary(double byPercent)
    {
        double raise = salary*byPercent /100;
        salary +=raise;
    }
}

/**
	Employee类的子类：Manager
	@author TIAN
	@version 0.0.1
*/
class Manager extends Employee{
    double bonus;

    public Manager(String name,double salary,int year,int month,int day)
    {
        super(name,salary,year,month,day);
        bonus=0;
    }

    public void setBonus(double bonus){
        this.bonus=bonus;
    }
    public double getSalary(){
        double Salary=super.getSalary();
        return Salary+bonus;
    }
}
```



#### 5.1.4 继承层次

继承并不限于一个层次。例如，可以由Manager类派生Executive类。由一个公共父类派生出来的所有类的集合被称为继承层次。通常，一个祖先类可以拥有多个子孙继承链。例如，可以由Employee类派生出子类Programmer或Secretary，它们与Manager类没有任何关系。如图

![image-20250515152955728](./../IMG/image-20250515152955728-1747294198021-1.png)